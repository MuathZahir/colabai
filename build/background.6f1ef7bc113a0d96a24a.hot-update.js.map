{"version":3,"file":"background.6f1ef7bc113a0d96a24a.hot-update.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1PA","sources":["webpack://chrome-extension-boilerplate-react/./src/pages/Background/index.ts","webpack://chrome-extension-boilerplate-react/webpack/runtime/getFullHash"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nconsole.log('This is the background page.');\r\nconsole.log('Put the background scripts here.');\r\nimport { NotebookChangeTracker } from './change-tracker';\r\nimport ExtPay from 'extpay';\r\nlet notebookTracker;\r\nconst messages = [];\r\nvar extpay = new ExtPay('colab');\r\nextpay.startBackground();\r\nconsole.log('Background Service Worker Loaded');\r\nchrome.runtime.onInstalled.addListener(() => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log('Extension installed');\r\n}));\r\nchrome.action.setBadgeText({ text: 'ON' });\r\nchrome.action.onClicked.addListener(() => {\r\n    chrome.tabs.query({ active: true, currentWindow: true }, tabs => {\r\n        const activeTab = tabs[0];\r\n        chrome.tabs.sendMessage(activeTab.id, { message: 'clicked_browser_action' });\r\n    });\r\n});\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    const { action } = message;\r\n    switch (action) {\r\n        case 'generateAI':\r\n            console.log(\"Generating...\");\r\n            generateAIContent(message.prompt, message.content, message.model)\r\n                .then(() => {\r\n                sendResponse({ success: true });\r\n            })\r\n                .catch(error => {\r\n                console.error(\"Error generating AI content: \", error);\r\n                sendResponse({ success: false, error: error.message });\r\n            });\r\n            return true; // Indicate that the response will be sent asynchronously\r\n        default:\r\n            sendResponse({ success: false, error: `Invalid action: ${action}` });\r\n            return false;\r\n    }\r\n});\r\nfunction trackNotebookChanges(currentCells) {\r\n    const tracker = notebookTracker || new NotebookChangeTracker();\r\n    notebookTracker = tracker;\r\n    console.log('Tracking notebook changes');\r\n    return tracker.updateState(currentCells);\r\n}\r\nfunction generateAIContent(prompt, content, model = \"gpt-3.5-turbo\") {\r\n    var _a;\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        console.log(\"Generating AI content...\");\r\n        console.log(\"Previous content:\", content);\r\n        const changeLog = trackNotebookChanges(content);\r\n        console.log(changeLog);\r\n        if (messages.length == 0)\r\n            messages.push({ role: \"system\", content: system_prompt });\r\n        messages.push({\r\n            role: \"user\",\r\n            content: `Changes since last message:\\n\\n${changeLog}\\n\\nUser request: ${prompt}`\r\n        });\r\n        console.log(messages);\r\n        try {\r\n            // Send request to lambda function\r\n            const response = yield fetch('https://qgvdlmluaznyzdv4jkfrw3oqee0rvber.lambda-url.eu-north-1.on.aws/', {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    'Authorization': 'Bearer YOUR_AUTH_TOKEN'\r\n                },\r\n                body: JSON.stringify({\r\n                    messages: messages,\r\n                    model: model\r\n                })\r\n            });\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();\r\n            const decoder = new TextDecoder(\"utf-8\");\r\n            let done = false;\r\n            if (reader == null) {\r\n                throw new Error(\"Response body is null\");\r\n            }\r\n            while (!done) {\r\n                const { value, done: chunkDone } = yield reader.read();\r\n                if (value) {\r\n                    console.log(new TextDecoder().decode(value));\r\n                    let textChunk = decoder.decode(value, { stream: true });\r\n                    let boundary;\r\n                    const data = [];\r\n                    // Separate JSON objects that arrive together in a single chunk\r\n                    while ((boundary = textChunk.indexOf(\"}{\")) !== -1) {\r\n                        // Separate the first JSON object\r\n                        const jsonStr = textChunk.slice(0, boundary + 1);\r\n                        textChunk = textChunk.slice(boundary + 1);\r\n                        // Parse and process the JSON\r\n                        data.push(JSON.parse(jsonStr));\r\n                    }\r\n                    // Process the remaining JSON\r\n                    data.push(JSON.parse(textChunk));\r\n                    chrome.tabs.query({ active: true, currentWindow: true }, tabs => {\r\n                        data.forEach((data) => {\r\n                            chrome.tabs.sendMessage(tabs[0].id, {\r\n                                action: 'streamed_response',\r\n                                content: data.content,\r\n                                done: data.done\r\n                            });\r\n                        });\r\n                    });\r\n                }\r\n                done = chunkDone;\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error(\"Error generating AI content: \", error);\r\n        }\r\n    });\r\n}\r\nconst system_prompt = `# Google Colab Cell Operations Guide\n\n## Basic Operations\nUse these commands to manipulate notebook cells:\n\n1. Create: \n@CREATE[type=markdown|code, position=top|bottom|after:cell-{id}|before:cell-{id}]\ncontent\n@END\n\n2. Edit (remember that the content in the edit operation replaces all previous content):\n@EDIT[cell-{id}]\ncontent\n@END\n\n3. Delete:\n@DELETE[cell-{id}]\n\n## Response Structure\n- Start operations with '@START_CODE'\n- End operations with '@END_CODE'\n- Write explanatory text before/after markers\n- Keep responses brief and clear\n\n## Notebook Guidelines\n- Use H1 for main topic, H2/H3 for sections\n- Start with imports/setup\n- Include context in markdown cells before code\n- Write clean, commented code in logical chunks\n- End with summary/conclusion\n\n## Changelog\nChanges between '@CHANGELOG' and '@END_CHANGELOG' are informational only - do not include in responses.\n\nRemember:\n- Operations execute in sequence\n- Preserve original formatting between @CREATE/@EDIT and @END\n- Maintain proper code indentation\n- Avoid redundant and empty content\n- Use descriptive names and helpful comments`;\r\n// const system_prompt = `Google Colab Notebook Cell Manipulation Guidelines\r\n// You can perform the following operations on notebook cells. Use these command markers to specify operations:\r\n// Cell Operations:\r\n// 1. Create new cell:\r\n// @CREATE[type=markdown|code, position=top|bottom|after:cell-{cellId}|before:cell-{cellId}]\r\n// content\r\n// @END\r\n// 2. Delete cell:\r\n// @DELETE[cell-{cellId}]\r\n// 3. Edit existing cell (remember that in edit, the new content replaces all the previous content. So always write the whole cell from start to end):\r\n// @EDIT[cell-{cellId}]\r\n// new content\r\n// @END\r\n// These are the ONLY operations you can perform on notebook cells. Make sure to follow the correct syntax and structure for each operation.\r\n// Required Structure:\r\n// - Start with H1 title for main topic\r\n// - Use H2/H3 headers for sections/subsections\r\n// - Begin with imports/setup\r\n// - End with summary/conclusion\r\n// Markdown Cells:\r\n// - Use formatting: bold, italic, lists, tables\r\n// - Add context before code cells\r\n// - Include LaTeX for math equations\r\n// - Embed diagrams/charts where needed\r\n// Code Cells:\r\n// - Break into logical chunks\r\n// - Add helpful comments\r\n// - Use descriptive names\r\n// - Group related code together\r\n// Notebook Changes (Between @CHANGELOG and @END_CHANGELOG):\r\n// - You will receive a list of changes that happened to the notebook cells since the last message\r\n// - This will include changes you made as well as changes made by the user\r\n// - These are not commands, but a summary of changes that happened before. Don't include these in your response\r\n// - These changes are cumulative and will be sent in sequence\r\n// Start and End Markers:\r\n// - To start writing the operations use @START_CODE\r\n// - To end writing the operations use @END_CODE\r\n// - You can write in normal text before and after these markers, explaining what you are doing or replying to the user\r\n// - Be very brief and clear in your responses before and after the markers. Also don't attempt to write in markdown format\r\n// Sample Examples:\r\n// 1. Create new markdown cell after cell 123:\r\n// @CREATE[type=markdown, position=after:cell-123]\r\n// ## Data Processing\r\n// In this section, we'll clean our dataset\r\n// @END\r\n// 2. Create new code cell at bottom:\r\n// @CREATE[type=code, position=bottom]\r\n// def process_data(df):\r\n//     return df.dropna()\r\n// @END\r\n// 3. Edit existing cell:\r\n// @EDIT[cell-456]\r\n// import pandas as pd\r\n// import numpy as np\r\n// @END\r\n// 4. Delete cell:\r\n// @DELETE[cell-789]\r\n// Full Example:\r\n// Sure thing! Here's a sample structure for a data analysis project:\r\n// @START_CODE\r\n// @CREATE[type=markdown, position=top]\r\n// # Data Analysis Project\r\n// @END\r\n// @CREATE[type=code, position=bottom]\r\n// import pandas as pd\r\n// @END\r\n// @EDIT[cell-123]\r\n// df = pd.read_csv('data.csv')\r\n// @END\r\n// ...\r\n// @END_CODE\r\n// This will help you get started with your project. Let me know if you need any more help!\r\n// Remember:\r\n// - Each operation must use the correct syntax\r\n// - Cell IDs must be specified for position-dependent operations\r\n// - Operations are executed in sequence\r\n// - Content between @CREATE/@EDIT and @END maintains original formatting\r\n// - For code cells, ensure proper indentation is preserved\r\n// - Be smart with the layout. If part of the content is already present, don't repeat it. Remove unnecessary or redundant content.\r\n// Output Format:\r\n// The assistant should provide cell operations using the above syntax. Multiple operations can be specified in sequence. The final output should be a well-structured notebook with the requested changes.`;\r\nchrome.commands.onCommand.addListener(command => {\r\n    console.log(`Command: ${command}`);\r\n    if (command === 'refresh_extension') {\r\n        chrome.runtime.reload();\r\n    }\r\n});\r\n","__webpack_require__.h = () => (\"0e95d7a1244c8268cf1b\")"],"names":[],"sourceRoot":""}